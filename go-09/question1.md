### 总结几种 socket 粘包的解包方式: fix length/delimiter based/length field based frame decoder。尝试举例其应用

## 什么是粘包/半包？

- 粘包：
  - 发送方发了两条消息：ABC、DEF
  - 接收方收到一条消息：ABCDEF

- 半包：
  - 发送方发了一条消息：ABCDEF
  - 接收方收到两条消息：ABC、DEF


## 为什么会有粘包/半包问题？

- TCP

TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议。

对于 TCP 来说，传输数据是以流的形式，而流数据没有明确的开始结束边界，也就没有办法判断哪那一段流属于哪一个消息。

- Socket

Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层。可以理解为 TCP/IP 网络的 API。

- 流量控制

流量控制用来避免发送方发送数据过快而使接收方来不及完全收下，一般由接收方通知发送方来进行调控。

TCP 使用滑动窗口协议来实现流量控制。接收方在 “接收窗口” 域指出还可接收的字节数量。发送方在没有新的确认包的情况下至多发送 “接收窗口” 允许的字节数量。接收方可修改 “接收窗口” 的值。

如果接收方以很小的增量来处理到来的数据，它就会发布一系列小的接收窗口。在 TCP 的数据包中发送一些很小的字节，相对于 TCP 包头是很大的开销。解决这个问题，就要避免对小的 Window Size 做出响应，直到有足够大的 Window Size 再响应。

为了提高 TCP 的传输效率，Nagle 算法被设计出来，用在发送方发送数据时做延时处理。

条件一：Window Size >= MSS 且 Data Size >= MSS；

条件二：等待时间或是超时 200ms。

> MSS：Maximum segment size 最大分段大小。是在单个分段中TCP愿意接受的数据的字节数最大值。

这两个条件有一个满足，才会发送数据，否则就积累数据。Nagle 算法默认是打开的，所以对于一些需要小包场景的程序——比如像 telnet 这样的交互性程序，需要关闭这个算法。可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法。

## 怎么解决粘包/半包？

1. 固定长度（fix length）

   发送方发送消息和接收方接收消息都使用统一的大小。当有效数据量小于该固定长度时，会出现资源浪费。

2. 基于长度字段解码（length field based frame decoder）

   封装请求协议，在协议头中增加表示数据正文大小的字段。接收方从字节流中按这个字段给定的长度读取数据。但这种方式编码成本较大。

   > HTTP 消息中使用 Content-Length 头表示 HTTP 消息的数据负载大小，应用层协议解析的时候就能从中分离出完整的 HTTP 消息。

3. 基于分隔符（delimiter based）

   在消息的结尾增加特殊字符确定数据流的边界。

   > HTTP 消息发送内容大小不确定时，会使用该策略。并使用块传输的机制，HTTP 头中也不再包含 Content-Length 。


## References

1. 传输控制协议 https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE
